[["index.html", "Introduction to R for Geospatial Data 1 Preface", " Introduction to R for Geospatial Data Aditya Ranganath 2021-11-09 1 Preface This lesson introduces R for users interested in geospatial data. It is taken from the Data Carpentry lesson available here "],["introduction-to-r-and-r-studio.html", "2 Introduction to R and R Studio 2.1 Introduction to R 2.2 Using R as a calculator 2.3 Comparing things 2.4 Variables and assignment 2.5 Installing packages", " 2 Introduction to R and R Studio 2.1 Introduction to R Much of your time in R will be spent in the R interactive console. This is where you will run all of your code, and can be a useful environment to try out ideas before adding them to an R script file. This console in RStudio is the same as the one you would get if you typed in R in your command-line environment. The first thing you will see in the R interactive session is a bunch of information, followed by a “&gt;” and a blinking cursor. In many ways this is similar to the shell environment you learned about during the shell lessons: it operates on the same idea of a “Read, evaluate, print loop”: you type in commands, R tries to execute them, and then returns a result. 2.2 Using R as a calculator The simplest thing you could do with R is do arithmetic: 1+100 ## [1] 101 R will print out the answer with a preceding [1]. Don’t worry about this for now, we’ll explain that later. For now, think of it as indicating output. As with bash, if you type an incomplete command, R will wait for you to complete it: 1+ Any time you hit return and the R session show a + instead of a &gt; it means it’s waiting for you to complete the command. If you want to cancel a command, you can simply hit ESC and RStudio will give you back the “&gt;” prompt. When using R as a calculator, the order of operations is the same as you would have learned back in school. From highest to lowest precedence: Parentheses: (, ) Exponents: ^ or ** Divide: / Multiply: * Add: + Subtract: - 3+5*2 ## [1] 13 (3+5)*2 ## [1] 16 (3 + (5 * (2 ^ 2))) # hard to read ## [1] 23 3 + 5 * 2 ^ 2 # clear, if you remember the rules ## [1] 23 3 + 5 * (2 ^ 2) # if you forget some rules, this might help ## [1] 23 The text after each line of code is called a “comment”. Anything that follows after the hash (or octothorpe) symbol # is ignored by R when it executes code. Really small or large numbers get a scientific notation: 2/10000 ## [1] 2e-04 This is shorthand for \"multiplied by 10^XX. So 2e-4 is shorthand for 2*10^(-4). You can write numbers in scientific notation too: 5e3 ## [1] 5000 Don’t worry about trying to remember every function in R. You can look them up on Google, or if you can remember the start of the function’s name, use the tab completion in RStudio. This is one advantage that RStudio has over R on its own, it has auto-completion abilities that allow you to more easily look up functions, their arguments, and the values that they take. Typing a ? before the name of a command will open the help page for that command. As well as providing a detailed description of the command and how it works, scrolling to the bottom of the help page will usually show a collection of code examples which illustrate command usage. We’ll go through an example later. 2.3 Comparing things We can also do comparison in R: 1==1 # equality; note two equals signs, read as &#39;is equal to&#39; ## [1] TRUE 1 != 2 # inequality (read as &#39;is not equal to&#39;) ## [1] TRUE 1&lt;2 # less than ## [1] TRUE 1&lt;=1 # less than or equal to ## [1] TRUE 1&gt;0 # greater than ## [1] TRUE 1 &gt;= -9 # greater than or equal to ## [1] TRUE 2.4 Variables and assignment We can store values in variables using the assignment operator &lt;- like this: x&lt;-1/40 This operation assigned the value 1/40 to the variable x. Notice that assignment does not print a value. Instead, we stored it for later in the variable x, which is now associated with 1/40. You can confirm this by printing x, which returns the value 0.025: x ## [1] 0.025 More More precisely, the stored value is a decimal approximation of this fraction called a floating point number. Look for the Environment tab in one of the panes of RStudio, and you will see that x and its value have appeared. Our variable x can be used in place of a number in any calculation that expects a number: log(x) ## [1] -3.688879 Note also that variables can be reassigned: x&lt;-100 x used to contain the value 0.025 and and now it has the value 100. Assignment values can contain the variable being assigned to: x &lt;- x + 1 #notice how RStudio updates its description of x on the top right tab y &lt;- x * 2 The right hand side of the assignment can be any valid R expression. The right hand side is fully evaluated before the assignment occurs. Variable names can contain letters, numbers, underscores and periods. They cannot start with a number nor contain spaces at all. Different people use different conventions for long variable names, these include periods.between.words underscores_between_words camelCaseToSeparateWords What you use is up to you, but be consistent. It is also possible to use the = operator for assignment: x=1/40 But this is much less common among R users. The most important thing is to be consistent with the operator you use. There are occasionally places where it is less confusing to use &lt;- than =, and it is the most common symbol used in the community. So the recommendation is to use &lt;-. 2.5 Installing packages We can use R as a calculator to do mathematical operations (e.g., addition, subtraction, multiplication, division), as we did above. However, we can also use R to carry out more complicated analyses, make visualizations, and much more. In later episodes, we’ll use R to do some data wrangling, plotting, and saving of reformatted data. R coders around the world have developed collections of R code to accomplish themed tasks (e.g., data wrangling). These collections of R code are known as R packages. It is also important to note that R packages refer to code that is not automatically downloaded when we install R on our computer. Therefore, we’ll have to install each R package that we want to use (more on this below). We will practice using the dplyr package to wrangle our datasets in episode 6 and will also practice using the ggplot2 package to plot our data in episode 7. To give an example, the dplyr package includes code for a function called filter(). A function is something that takes input(s) does some internal operations and produces output(s). For the filter() function, the inputs are a dataset and a logical statement (i.e., when data value is greater than or equal to 100) and the output is data within the dataset that has a value greater than or equal to 100. There are two main ways to install packages in R: If you are using RStudio, we can go to Tools &gt; Install Packages… and then search for the name of the R package we need and click Install. We can use the install.packages( ) function. We can do this to install the dplyr R package. install.packages(&quot;dplyr&quot;) It’s important to note that we only need to install the R package on our computer once Now that we’ve installed the R package, we’re ready to use it! To use the R package, we need to “load” it into our R session. We can think of “loading” an R packages as telling R that we’re ready to use the package we just installed. It’s important to note that while we only have to install the package once, we’ll have to load the package each time we open R (or RStudio). To load an R package, we use the library( ) function. We can load the dplyr package like this: library(dplyr) "],["project-management-with-r-studio.html", "3 Project Management With R Studio", " 3 Project Management With R Studio "],["data-structures.html", "4 Data Structures 4.1 Data Types 4.2 Vectors and Type Coercion 4.3 Factors 4.4 Lists", " 4 Data Structures One of R’s most powerful features is its ability to deal with tabular data, of the sort that can be displayed in a spreadsheet or CSV file. Let’s start by downloading and reading in the file nordic-data.csv. We’ll save this data as an object named nordic. nordic&lt;-read.csv(&quot;nordic-data.csv&quot;) Note that I was able to read in the data using just nordic-data.csv as the argument to the read.csv function (without any additional information on the file path) since I’m already in the working directory that contains the data. The read.table is used for reading in tabular data stored in a text file where the columns of data are separated by punctuation characters such as commas (as with CSV files). Tabs and commas are the most common punctuation characters used to separate or delimit data points in csv files. For convenience, R provides 2 other versions of read.table. These are read.csv for files where the data are separated with commas and read.delim for files where the data are separated with tabs. Of these three functions, read.csv is the most commonly used, and is what we’ll use in this tutorial. It’s worth noting that if needed, it’s possible to override the default punctuation marks for both read.csv and read.delim. We can begin exploring our dataset right away, pulling out columns by specifying them using the $ operator: Let’s start by pulling out the “country” column from the nordic dataset: nordic$country ## [1] &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; And the life expectancy variable (\"lifeExp): nordic$lifeExp ## [1] 77.2 80.0 79.0 We can also do other operations on the columns. For example, if we discovered that we made a mistake, and that the life expectancy is actually two years higher, we can take the “lifeExp” column and add two to all the observations: nordic$lifeExp + 2 ## [1] 79.2 82.0 81.0 What if we do something similar, and add up the “lifeExp” and “country” columns from the nordic dataset? nordic$lifeExp + nordic$country This will return an error that complains about a non-numeric argument to a binary operator. It’s important to understand what exactly this means in order to successfully analyze data in R. 4.1 Data Types You might have guessed that the error arises because the calculation 77.2 plus Denmark is nonsense. If so, you’re correct, and already have some intuition for an important concept in programming called data classes. We can use the class function to ask what class of data something is. For example, to see what class the “lifeExp” variable is, we can type the following: class(nordic$lifeExp) ## [1] &quot;numeric&quot; We can see that it’s numeric. There are 6 main data types of classes: numeric, integer, complex, logical, character, and factor. Let’s see some more examples. class(3.14) ## [1] &quot;numeric&quot; class(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers ## [1] &quot;integer&quot; class(1+1i) ## [1] &quot;complex&quot; class(TRUE) ## [1] &quot;logical&quot; class(&#39;banana&#39;) ## [1] &quot;character&quot; class(factor(&#39;banana&#39;)) ## [1] &quot;factor&quot; No matter how complicated our analyses become, all data in R is interpreted as a specific data class. That strictness has important consequences; thing won’t run as expected or at all if there’s a mismatch between the class of data you’re working with and what R is expecting. So, it’s important to be aware of the class your data is stored in, to avoid any errors or surprises. Let’s take a look at another example of why it’s important to be aware of data classes. Let’s say that a user has added new details of life expectancy. This information is in the nordic-data-2.csv. We’ll load the new nordic data as nordic_2 and check the class of the data in the lifeExp column: nordic_2&lt;-read.csv(&quot;nordic-data-2.csv&quot;) class(nordic_2$lifeExp) ## [1] &quot;character&quot; Even though the lifeExp data looks like it’s numeric, R is treating it as character data under the hood. If we try to do the same math we did on them before, we’ll get into trouble: nordic_2$lifeExp + 2 Running that code will result in the “non-numeric argument to binary operator” that we encountered before. What happened? When R reads a csv file into one of these tables, it insists that everything in a column be the same class; if it can’t understand everything in the column as numeric, then nothing gets to be numeric. The table that R loaded our nordic data into is something called a dataframe, and it’s our first example of something called a data structure, which is essentially a structure that R knows how to build out of the basic data types. We can see that it is a dataframe by calling the class() function on it: class(nordic) ## [1] &quot;data.frame&quot; In order to successfully use our data in R, we need to understand what the basic data structures are, and how they behave. 4.2 Vectors and Type Coercion To better understand the behavior we’ve just observed, let’s meet another of the data structures: the vector. my_vector&lt;-vector(length=3) my_vector ## [1] FALSE FALSE FALSE A vector in R is essentially an ordered list of things, with the special condition that everything in the vector must be of the same basic data type. If you don’t choose the data type, it’ll default to logical; or, you can declare the empty vector of whatever type you like. For example, if we want to create an empty character vector, we can type the following: another_vector&lt;-vector(mode=&#39;character&#39;, length=3) another_vector ## [1] &quot;&quot; &quot;&quot; &quot;&quot; If you want to check if something is a vector, you can use sthe str function, which is short for “structure”: str(another_vector) ## chr [1:3] &quot;&quot; &quot;&quot; &quot;&quot; This output indicates the basic data type found in this vector (in this case, chr), as well as the number of things in the vector (or more precisely, the indexes which in this case are 1:3), and a few examples of what’s actually in the vector (empty character strings, in this case). If we similarly pass the lifeExp column of nordic to the str function: str(nordic$lifeExp) ## num [1:3] 77.2 80 79 We see that nordic$lifeExp is a vector too. In fact, the columns of data we load into R data frames are all vectors, and that’s the root cause of why R forces everything in a column to be the same basic data type. You can also use make vectors with explicit contents using the combine function. For example, let’s say we want to make a vector with the numbers 2,6, and 3: combine_vector&lt;-c(2,6,3) combine_vector ## [1] 2 6 3 Let’s try another one. Given what we’ve learned so far, what do you think the following will produce? quiz_vector&lt;-c(2,6,&#39;3&#39;) When we open that object, quiz_vector ## [1] &quot;2&quot; &quot;6&quot; &quot;3&quot; We see that all of the elements in the vector are strings. This is an example of something called type coercion, which is often the source of surprises that can frustrate your data analysis. Type coercion is an important reason why we need to be aware of the basic data types and how R will interpret them. Let’s take a look at another example that shows how, when R encounters a mix of types (here numeric and character) to be combined into a single vector, it will force them all to be the same type. Consider, for example, a vector with character and logical elements: coercion_vector&lt;-c(&#39;a&#39;, TRUE) # When we inspect the vector, we can see that the elements have been coerced into character elements: coercion_vector ## [1] &quot;a&quot; &quot;TRUE&quot; Let’s try another vector, this time with numeric and logical elements: another_coercion_vector&lt;-c(0, TRUE) # When we open this vector, we see both elements coerced to numeric another_coercion_vector ## [1] 0 1 The coercion rules go from logical to integer to numeric to complex to character. In other words, that sequence essentially defines a flowchart that specifies how elements with different classes will be transformed during the coercion process. You can try to force coercion against this flow using the as. functions: For example, let’s start with a character vector: character_vector_example&lt;-c(&#39;0&#39;, &#39;2&#39;, &#39;4&#39;) character_vector_example ## [1] &quot;0&quot; &quot;2&quot; &quot;4&quot; Now, let’s say we want to coerce this character vector into a numeric one. We can do so with the as.numeric function: character_coerced_to_numeric&lt;-as.numeric(character_vector_example) character_coerced_to_numeric ## [1] 0 2 4 Alternatively, let’s say we want to coerce a numeric vector into a logical one. We can do so with the as.logical function. numeric_coerced_to_logical&lt;-as.logical(character_coerced_to_numeric) numeric_coerced_to_logical ## [1] FALSE TRUE TRUE The upshot of all this is that some surprising things can happen when R forces one basic data type into another. The central takeaway is that if your data doesn’t look like what you thought it would look like, or R throws an unexpected error, type coercion may be the culprit. In order to avoid potentially nasty surprises, you want to make sure that everything is the same type in your vectors and your columns of data frames. Continuing on with our discussion of vectors, the combine function c() will also append things to an existing vector. Let’s start with a new vector named ab_vector with the elements a and b: ab_vector&lt;-c(&#39;a&#39;, &#39;b&#39;) ab_vector ## [1] &quot;a&quot; &quot;b&quot; Now, let’s make a new vector and append ab_vector to it: combine_example&lt;-c(ab_vector, &#39;DC&#39;) combine_example ## [1] &quot;a&quot; &quot;b&quot; &quot;DC&quot; Similarly, you can also make series of numbers # This defines a vector with numeric elements from one to ten my_series&lt;-1:10 my_series ## [1] 1 2 3 4 5 6 7 8 9 10 We can do the same thing using the seq function: seq(10) ## [1] 1 2 3 4 5 6 7 8 9 10 And, we can also explicitly define the upper and lower bounds of the sequence, and the units by which the numbers increase or decrease. For example, if we want a sequence starting at 1 and ending at 10 in increments of 0.1 we can type the following: seq(1,10, by=0.1) ## [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 ## [20] 2.9 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9 4.0 4.1 4.2 4.3 4.4 4.5 4.6 4.7 ## [39] 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 6.0 6.1 6.2 6.3 6.4 6.5 6.6 ## [58] 6.7 6.8 6.9 7.0 7.1 7.2 7.3 7.4 7.5 7.6 7.7 7.8 7.9 8.0 8.1 8.2 8.3 8.4 8.5 ## [77] 8.6 8.7 8.8 8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0 It’s also possible to use functions to ask and answer questions about vectors. # Start with a vector of numbers from 1 to 10 sequence_example&lt;-seq(10) # Let&#39;s say we want to know the first two elements of this vector. We can type: head(sequence_example, n=2) ## [1] 1 2 # Let&#39;s say we want to know the last 4 elements of the vector tail(sequence_example, n=4) ## [1] 7 8 9 10 # Let&#39;s say we want to know the length of the vector, or in other words the number of elements it has length(sequence_example) ## [1] 10 # And finally, let&#39;s say we want to know the vector&#39;s class: class(sequence_example) ## [1] &quot;integer&quot; It’s useful to note that you can give names to elements in your vector: # Let&#39;s start with a vector of integers from 5 to 8 my_example&lt;-5:8 # We can supply names to the my_example vector elements by passing that vector through the &quot;names # function and then using a vector of names and the assignment operator to assign the names names(my_example)&lt;-c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) my_example ## a b c d ## 5 6 7 8 If we want to print the names of the vector elements, we can pass the vector through the names function: names(my_example) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; 4.3 Factors We’ve already noted that columns in data frames are vectors. For example # Examine the lifeExp column str(nordic$lifeExp) ## num [1:3] 77.2 80 79 # Or the &quot;year&quot; column str(nordic$year) ## int [1:3] 2002 2002 2002 That makes sense; but what about the country column? str(nordic$country) ## chr [1:3] &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; This brings us to another important data structure, which is called a factor. Factors look like character data, but are used to represent categorical information. For example, let’s make a vector of strings labeling nordic countries for all the countries in the study: nordic_countries&lt;-c(&#39;Norway&#39;, &#39;Finland&#39;, &#39;Denmark&#39;, &#39;Iceland&#39;, &#39;Sweden&#39;) nordic_countries ## [1] &quot;Norway&quot; &quot;Finland&quot; &quot;Denmark&quot; &quot;Iceland&quot; &quot;Sweden&quot; # Let&#39;s examine the vector&#39;s structure str(nordic_countries) ## chr [1:5] &quot;Norway&quot; &quot;Finland&quot; &quot;Denmark&quot; &quot;Iceland&quot; &quot;Sweden&quot; We can turn a vector into a factor by passing the vector to the factor function: categories&lt;-factor(nordic_countries) # Confirm that categories is a factor class(categories) ## [1] &quot;factor&quot; str(categories) ## Factor w/ 5 levels &quot;Denmark&quot;,&quot;Finland&quot;,..: 4 2 1 3 5 This output suggests that there are 5 possible categories in the data, but R is doing something that may be surprising: instead of printing out the strings we gave it, we got back a bunch of numbers instead. R has replaced our human-readable categories with numbered indices under the hood; this is necessary, since many statistical calculations utilise such numerical representations for categorical data. When doing statistical modeling, it’s important to know how these numbered indices correspond to our categorical variables, and to know what the baseline levels are. This is assumed to be the first factor, but by default factors are labeled in alphabetical order. You can explicitly control or change this labeling by specifying the levels. For example, # Let&#39;s start with a new character vector called mydata mydata&lt;-c(&quot;case&quot;, &quot;control&quot;, &quot;control&quot;, &quot;case&quot;) # Then let&#39;s convert this character vector into a factor, and specify the levels such that &quot;control&quot; # is represented by 1, and &quot;case&quot; by 2 factor_ordering_example&lt;-factor(mydata, levels=c(&quot;control&quot;, &quot;case&quot;)) Now, let’s inspect this object’s structure using str: str(factor_ordering_example) ## Factor w/ 2 levels &quot;control&quot;,&quot;case&quot;: 2 1 1 2 This output confirms that “control” corresponds to one, and “case” corresponds to 2, as we intended. 4.4 Lists Another data structure that’s important to be familiar with is the list. A list is in some ways simpler than the other types, since you can put anything you want in it. # Make a list with elements of various classes list_example&lt;-list(1, &quot;a&quot;, TRUE, c(2,6,7)) list_example ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 2 6 7 Let’s try another one: another_list&lt;-list(title=&quot;Numbers&quot;, numbers=1:10, data=TRUE) another_list ## $title ## [1] &quot;Numbers&quot; ## ## $numbers ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $data ## [1] TRUE We can now use our understanding of lists to better understand how data frames are put together. Let’s compare the structure of nordic and another_list: str(nordic) ## &#39;data.frame&#39;: 3 obs. of 3 variables: ## $ country: chr &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; ## $ year : int 2002 2002 2002 ## $ lifeExp: num 77.2 80 79 str(another_list) ## List of 3 ## $ title : chr &quot;Numbers&quot; ## $ numbers: int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ data : logi TRUE We can see that the output for these two objects look very similar. This is actually because data frames are lists “under the hood.” Data frames are actually a special case of lists where each element (the columns of the data frame) have the same lengths. In our nordic example, we have an integer, a double, and a logical variable. As we’ve seen already, each column of data frame is a vector: nordic$country ## [1] &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; We can also extract through an alternative notation that specifies the column’s index: nordic[,1] ## [1] &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; If we want to inspect that column’s class: class(nordic[,1]) ## [1] &quot;character&quot; And if we want to know the column’s structure: str(nordic[,1]) ## chr [1:3] &quot;Denmark&quot; &quot;Sweden&quot; &quot;Norway&quot; We can now turn to rows. Each row is an observation of different variables, and itself a data frame, and can therefore be composed of elements of different types: # Let&#39;s inspect the first row nordic[1,] ## country year lifeExp ## 1 Denmark 2002 77.2 Now, let’s see the first row’s class and confirm that it’s a data frame: class(nordic[1,]) ## [1] &quot;data.frame&quot; And for more information, we can inspect its structure: str(nordic[1,]) ## &#39;data.frame&#39;: 1 obs. of 3 variables: ## $ country: chr &quot;Denmark&quot; ## $ year : int 2002 ## $ lifeExp: num 77.2 "],["exploring-data-frames.html", "5 Exploring Data Frames 5.1 Realistic Example 5.2 Adding columns and rows in data frames 5.3 Factors 5.4 Appending to a data frame", " 5 Exploring Data Frames At this point, you’ve seen it all: in the last lesson, we toured all the basic data types and data structures in R. Everything you do will be a manipulation of those tools. But most of the time, the star of the show is the data frame—the table that we created by loading information from a csv file. In this lesson, we’ll learn a few more things about working with data frames. 5.1 Realistic Example We already learned that the columns of a data frame are vectors, so that our data are consistent in type throughout the columns. So far, you have seen the basics of manipulating data frames with our nordic data; now, let’s use those skills to analyze a more complext dataset. Let’s go ahead and read in the gapminder dataset and assign it to an object named “gapminder” gapminder&lt;-read.csv(&quot;gapminder_data.csv&quot;) Let’s investigate the gapminder data frame a bit; the first thing we should always do is get a sense of what the data looks like with the str function: str(gapminder) ## &#39;data.frame&#39;: 1704 obs. of 6 variables: ## $ country : chr &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... ## $ year : int 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ pop : num 8425333 9240934 10267083 11537966 13079460 ... ## $ continent: chr &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; ... ## $ lifeExp : num 28.8 30.3 32 34 36.1 ... ## $ gdpPercap: num 779 821 853 836 740 ... We can also examine individual columns of the data frame with our class function: class(gapminder$year) ## [1] &quot;integer&quot; class(gapminder$country) ## [1] &quot;character&quot; We can also apply str to individual columns str(gapminder$country) ## chr [1:1704] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... We can also interrogate the data frame for information about its dimensions. Recall from earlier that when we passed gapminder to the str function, the output informed us that there were 1704 observations and 6 variables in gapminder. Keeping that in mind what do you think the following will produce, and why? length(gapminder) ## [1] 6 A fair guess would have been to say that the length of a data frame would be the number of rows (1704 in this case), but that’s not the case; the length actually returns the number of columns. Let’s confirm the class of gapminder class(gapminder) ## [1] &quot;data.frame&quot; To get the number of rows in the dataset, we can use the nrow function: nrow(gapminder) ## [1] 1704 To get the number of columns, we can use the ncol function: ncol(gapminder) ## [1] 6 If we want to get both at once, and get a fuller sense of a dataset’s dimensions at one go, we can use the dim function: dim(gapminder) ## [1] 1704 6 We’ll also likely want to know the titles of all the columns. We can use the colnames function to get those names: colnames(gapminder) ## [1] &quot;country&quot; &quot;year&quot; &quot;pop&quot; &quot;continent&quot; &quot;lifeExp&quot; &quot;gdpPercap&quot; At this point, it’s it’s important to ask ourselves if the structure R is reporting matches our intuition or expectations; do the basic data types reported for each column make sense? If not, we need to sort any problems out now before they turn into bad surprises down the road, using what we’ve learned about how R interprets data, and the importance of strict consistency in how we record our data. Once we’re happy that the data types and structures seem reasonable, it’s time to start digging into our data proper. Check out the first few lines: head(gapminder) ## country year pop continent lifeExp gdpPercap ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 5.2 Adding columns and rows in data frames Let’s talk about adding columns and rows in data frames. Let’s assume that we’d like to create a new column to hold information on whether the life expectancy is below or above the world’s average life expectancy of 70.5: below_average&lt;-gapminder$lifeExp&lt;70.5 Let’s refresh our memories about what gapminder looks like: head(gapminder) ## country year pop continent lifeExp gdpPercap ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 And now, let’s add below_average as a column using the cbind function: cbind(gapminder, below_average) ## country year pop continent lifeExp gdpPercap below_average ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 TRUE ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 TRUE ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 TRUE ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 TRUE ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 TRUE ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 TRUE ## 7 Afghanistan 1982 12881816 Asia 39.854 978.0114 TRUE ## 8 Afghanistan 1987 13867957 Asia 40.822 852.3959 TRUE ## 9 Afghanistan 1992 16317921 Asia 41.674 649.3414 TRUE ## 10 Afghanistan 1997 22227415 Asia 41.763 635.3414 TRUE ## 11 Afghanistan 2002 25268405 Asia 42.129 726.7341 TRUE ## 12 Afghanistan 2007 31889923 Asia 43.828 974.5803 TRUE ## 13 Albania 1952 1282697 Europe 55.230 1601.0561 TRUE ## 14 Albania 1957 1476505 Europe 59.280 1942.2842 TRUE ## 15 Albania 1962 1728137 Europe 64.820 2312.8890 TRUE ## 16 Albania 1967 1984060 Europe 66.220 2760.1969 TRUE ## 17 Albania 1972 2263554 Europe 67.690 3313.4222 TRUE ## 18 Albania 1977 2509048 Europe 68.930 3533.0039 TRUE ## 19 Albania 1982 2780097 Europe 70.420 3630.8807 TRUE ## 20 Albania 1987 3075321 Europe 72.000 3738.9327 FALSE ## 21 Albania 1992 3326498 Europe 71.581 2497.4379 FALSE ## 22 Albania 1997 3428038 Europe 72.950 3193.0546 FALSE ## 23 Albania 2002 3508512 Europe 75.651 4604.2117 FALSE ## 24 Albania 2007 3600523 Europe 76.423 5937.0295 FALSE ## 25 Algeria 1952 9279525 Africa 43.077 2449.0082 TRUE ## 26 Algeria 1957 10270856 Africa 45.685 3013.9760 TRUE ## 27 Algeria 1962 11000948 Africa 48.303 2550.8169 TRUE ## 28 Algeria 1967 12760499 Africa 51.407 3246.9918 TRUE ## 29 Algeria 1972 14760787 Africa 54.518 4182.6638 TRUE ## 30 Algeria 1977 17152804 Africa 58.014 4910.4168 TRUE ## 31 Algeria 1982 20033753 Africa 61.368 5745.1602 TRUE ## 32 Algeria 1987 23254956 Africa 65.799 5681.3585 TRUE ## 33 Algeria 1992 26298373 Africa 67.744 5023.2166 TRUE ## 34 Algeria 1997 29072015 Africa 69.152 4797.2951 TRUE ## 35 Algeria 2002 31287142 Africa 70.994 5288.0404 FALSE ## 36 Algeria 2007 33333216 Africa 72.301 6223.3675 FALSE ## 37 Angola 1952 4232095 Africa 30.015 3520.6103 TRUE ## 38 Angola 1957 4561361 Africa 31.999 3827.9405 TRUE ## 39 Angola 1962 4826015 Africa 34.000 4269.2767 TRUE ## 40 Angola 1967 5247469 Africa 35.985 5522.7764 TRUE ## 41 Angola 1972 5894858 Africa 37.928 5473.2880 TRUE ## 42 Angola 1977 6162675 Africa 39.483 3008.6474 TRUE ## 43 Angola 1982 7016384 Africa 39.942 2756.9537 TRUE ## 44 Angola 1987 7874230 Africa 39.906 2430.2083 TRUE ## 45 Angola 1992 8735988 Africa 40.647 2627.8457 TRUE ## 46 Angola 1997 9875024 Africa 40.963 2277.1409 TRUE ## 47 Angola 2002 10866106 Africa 41.003 2773.2873 TRUE ## 48 Angola 2007 12420476 Africa 42.731 4797.2313 TRUE ## 49 Argentina 1952 17876956 Americas 62.485 5911.3151 TRUE ## 50 Argentina 1957 19610538 Americas 64.399 6856.8562 TRUE ## 51 Argentina 1962 21283783 Americas 65.142 7133.1660 TRUE ## 52 Argentina 1967 22934225 Americas 65.634 8052.9530 TRUE ## 53 Argentina 1972 24779799 Americas 67.065 9443.0385 TRUE ## 54 Argentina 1977 26983828 Americas 68.481 10079.0267 TRUE ## 55 Argentina 1982 29341374 Americas 69.942 8997.8974 TRUE ## 56 Argentina 1987 31620918 Americas 70.774 9139.6714 FALSE ## 57 Argentina 1992 33958947 Americas 71.868 9308.4187 FALSE ## 58 Argentina 1997 36203463 Americas 73.275 10967.2820 FALSE ## 59 Argentina 2002 38331121 Americas 74.340 8797.6407 FALSE ## 60 Argentina 2007 40301927 Americas 75.320 12779.3796 FALSE ## 61 Australia 1952 8691212 Oceania 69.120 10039.5956 TRUE ## 62 Australia 1957 9712569 Oceania 70.330 10949.6496 TRUE ## 63 Australia 1962 10794968 Oceania 70.930 12217.2269 FALSE ## 64 Australia 1967 11872264 Oceania 71.100 14526.1246 FALSE ## 65 Australia 1972 13177000 Oceania 71.930 16788.6295 FALSE ## 66 Australia 1977 14074100 Oceania 73.490 18334.1975 FALSE ## 67 Australia 1982 15184200 Oceania 74.740 19477.0093 FALSE ## 68 Australia 1987 16257249 Oceania 76.320 21888.8890 FALSE ## 69 Australia 1992 17481977 Oceania 77.560 23424.7668 FALSE ## 70 Australia 1997 18565243 Oceania 78.830 26997.9366 FALSE ## 71 Australia 2002 19546792 Oceania 80.370 30687.7547 FALSE ## 72 Australia 2007 20434176 Oceania 81.235 34435.3674 FALSE ## 73 Austria 1952 6927772 Europe 66.800 6137.0765 TRUE ## 74 Austria 1957 6965860 Europe 67.480 8842.5980 TRUE ## 75 Austria 1962 7129864 Europe 69.540 10750.7211 TRUE ## 76 Austria 1967 7376998 Europe 70.140 12834.6024 TRUE ## 77 Austria 1972 7544201 Europe 70.630 16661.6256 FALSE ## 78 Austria 1977 7568430 Europe 72.170 19749.4223 FALSE ## 79 Austria 1982 7574613 Europe 73.180 21597.0836 FALSE ## 80 Austria 1987 7578903 Europe 74.940 23687.8261 FALSE ## 81 Austria 1992 7914969 Europe 76.040 27042.0187 FALSE ## 82 Austria 1997 8069876 Europe 77.510 29095.9207 FALSE ## 83 Austria 2002 8148312 Europe 78.980 32417.6077 FALSE ## 84 Austria 2007 8199783 Europe 79.829 36126.4927 FALSE ## 85 Bahrain 1952 120447 Asia 50.939 9867.0848 TRUE ## 86 Bahrain 1957 138655 Asia 53.832 11635.7995 TRUE ## 87 Bahrain 1962 171863 Asia 56.923 12753.2751 TRUE ## 88 Bahrain 1967 202182 Asia 59.923 14804.6727 TRUE ## 89 Bahrain 1972 230800 Asia 63.300 18268.6584 TRUE ## 90 Bahrain 1977 297410 Asia 65.593 19340.1020 TRUE ## 91 Bahrain 1982 377967 Asia 69.052 19211.1473 TRUE ## 92 Bahrain 1987 454612 Asia 70.750 18524.0241 FALSE ## 93 Bahrain 1992 529491 Asia 72.601 19035.5792 FALSE ## 94 Bahrain 1997 598561 Asia 73.925 20292.0168 FALSE ## 95 Bahrain 2002 656397 Asia 74.795 23403.5593 FALSE ## 96 Bahrain 2007 708573 Asia 75.635 29796.0483 FALSE ## 97 Bangladesh 1952 46886859 Asia 37.484 684.2442 TRUE ## 98 Bangladesh 1957 51365468 Asia 39.348 661.6375 TRUE ## 99 Bangladesh 1962 56839289 Asia 41.216 686.3416 TRUE ## 100 Bangladesh 1967 62821884 Asia 43.453 721.1861 TRUE ## 101 Bangladesh 1972 70759295 Asia 45.252 630.2336 TRUE ## 102 Bangladesh 1977 80428306 Asia 46.923 659.8772 TRUE ## 103 Bangladesh 1982 93074406 Asia 50.009 676.9819 TRUE ## 104 Bangladesh 1987 103764241 Asia 52.819 751.9794 TRUE ## 105 Bangladesh 1992 113704579 Asia 56.018 837.8102 TRUE ## 106 Bangladesh 1997 123315288 Asia 59.412 972.7700 TRUE ## 107 Bangladesh 2002 135656790 Asia 62.013 1136.3904 TRUE ## 108 Bangladesh 2007 150448339 Asia 64.062 1391.2538 TRUE ## 109 Belgium 1952 8730405 Europe 68.000 8343.1051 TRUE ## 110 Belgium 1957 8989111 Europe 69.240 9714.9606 TRUE ## 111 Belgium 1962 9218400 Europe 70.250 10991.2068 TRUE ## 112 Belgium 1967 9556500 Europe 70.940 13149.0412 FALSE ## 113 Belgium 1972 9709100 Europe 71.440 16672.1436 FALSE ## 114 Belgium 1977 9821800 Europe 72.800 19117.9745 FALSE ## 115 Belgium 1982 9856303 Europe 73.930 20979.8459 FALSE ## 116 Belgium 1987 9870200 Europe 75.350 22525.5631 FALSE ## 117 Belgium 1992 10045622 Europe 76.460 25575.5707 FALSE ## 118 Belgium 1997 10199787 Europe 77.530 27561.1966 FALSE ## 119 Belgium 2002 10311970 Europe 78.320 30485.8838 FALSE ## 120 Belgium 2007 10392226 Europe 79.441 33692.6051 FALSE ## 121 Benin 1952 1738315 Africa 38.223 1062.7522 TRUE ## 122 Benin 1957 1925173 Africa 40.358 959.6011 TRUE ## 123 Benin 1962 2151895 Africa 42.618 949.4991 TRUE ## 124 Benin 1967 2427334 Africa 44.885 1035.8314 TRUE ## 125 Benin 1972 2761407 Africa 47.014 1085.7969 TRUE ## 126 Benin 1977 3168267 Africa 49.190 1029.1613 TRUE ## 127 Benin 1982 3641603 Africa 50.904 1277.8976 TRUE ## 128 Benin 1987 4243788 Africa 52.337 1225.8560 TRUE ## 129 Benin 1992 4981671 Africa 53.919 1191.2077 TRUE ## 130 Benin 1997 6066080 Africa 54.777 1232.9753 TRUE ## 131 Benin 2002 7026113 Africa 54.406 1372.8779 TRUE ## 132 Benin 2007 8078314 Africa 56.728 1441.2849 TRUE ## 133 Bolivia 1952 2883315 Americas 40.414 2677.3263 TRUE ## 134 Bolivia 1957 3211738 Americas 41.890 2127.6863 TRUE ## 135 Bolivia 1962 3593918 Americas 43.428 2180.9725 TRUE ## 136 Bolivia 1967 4040665 Americas 45.032 2586.8861 TRUE ## 137 Bolivia 1972 4565872 Americas 46.714 2980.3313 TRUE ## 138 Bolivia 1977 5079716 Americas 50.023 3548.0978 TRUE ## 139 Bolivia 1982 5642224 Americas 53.859 3156.5105 TRUE ## 140 Bolivia 1987 6156369 Americas 57.251 2753.6915 TRUE ## 141 Bolivia 1992 6893451 Americas 59.957 2961.6997 TRUE ## 142 Bolivia 1997 7693188 Americas 62.050 3326.1432 TRUE ## [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 1562 rows ] If we don’t want to print the entire data frame every time, we can put our cbind command within a call to head to return only the first six lines of the output: head(cbind(gapminder, below_average)) ## country year pop continent lifeExp gdpPercap below_average ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 TRUE ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 TRUE ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 TRUE ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 TRUE ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 TRUE ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 TRUE Now let’s see what happens if we try to add a vector of below_average with a different number of entries than the number of rows in the gapminder data frame: below_average&lt;-c(TRUE, TRUE, TRUE, TRUE, TRUE) head(cbind(gapminder, below_average)) Running this leads to an error that says “arguments imply differing number of rows.” This happens because R wants to see one element in our new column for every row in the table. Let’s remind ourselves of the number of rows in gapminder: nrow(gapminder) ## [1] 1704 And the length of the below_average vector: length(below_average) ## [1] 1704 For the binding to work, we need to have the number of rows in gapminder equal to the length of below_average or we need the number of rows in gapminder to be a multiple of the length of below_average. Because gapminder does not have five rows or a multiple of five rows, the column binding failed. Let’s try again, this time with a below_average vector length of three: below_average&lt;-c(TRUE, TRUE, FALSE) head(cbind(gapminder, below_average)) ## country year pop continent lifeExp gdpPercap below_average ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 TRUE ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 TRUE ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 FALSE ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 TRUE ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 TRUE ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 FALSE This time, it worked, since 1704 is divisible by three. More specifically, what’s happening here is that the sequence TRUE, TRUE, FALSE is repeated over all the gapminder rows. Let’s go ahead and overwrite the content of gapminder with this new data frame: below_average&lt;-as.logical(gapminder$lifeExp&lt;70.5) gapminder&lt;-cbind(gapminder, below_average) Now how about adding rows? Recall that the rows of a data frame are lists. To add a new row, we can make a list and then use the rbind function to append the row to the existing data frame. Let’s see an example: new_row&lt;-list(&#39;Norway&#39;, 2016, 500000, &#39;Nordic&#39;, 80.3, 49400.0, FALSE) gapminder_norway&lt;-rbind(gapminder, new_row) tail(gapminder_norway) ## country year pop continent lifeExp gdpPercap below_average ## 1700 Zimbabwe 1987 9216418 Africa 62.351 706.1573 TRUE ## 1701 Zimbabwe 1992 10704340 Africa 60.377 693.4208 TRUE ## 1702 Zimbabwe 1997 11404948 Africa 46.809 792.4500 TRUE ## 1703 Zimbabwe 2002 11926563 Africa 39.989 672.0386 TRUE ## 1704 Zimbabwe 2007 12311143 Africa 43.487 469.7093 TRUE ## 1705 Norway 2016 500000 Nordic 80.300 49400.0000 FALSE That worked, because continent is being treated as a character vector. But what if it was considered a factor? gapminder$continent&lt;-as.factor(gapminder$continent) new_row&lt;-list(&#39;Norway&#39;, 2016, 500000, &#39;Nordic&#39;, 80.3, 49400.0, FALSE) gapminder_norway&lt;-rbind(gapminder, new_row) ## Warning in `[&lt;-.factor`(`*tmp*`, ri, value = &quot;Nordic&quot;): invalid factor level, NA generated tail(gapminder_norway) ## country year pop continent lifeExp gdpPercap below_average ## 1700 Zimbabwe 1987 9216418 Africa 62.351 706.1573 TRUE ## 1701 Zimbabwe 1992 10704340 Africa 60.377 693.4208 TRUE ## 1702 Zimbabwe 1997 11404948 Africa 46.809 792.4500 TRUE ## 1703 Zimbabwe 2002 11926563 Africa 39.989 672.0386 TRUE ## 1704 Zimbabwe 2007 12311143 Africa 43.487 469.7093 TRUE ## 1705 Norway 2016 500000 &lt;NA&gt; 80.300 49400.0000 FALSE You’ll notice that this time, the binding still works, but R gives us a warning. To see what’s going on, we need to learn a bit more about factors. 5.3 Factors The thing to note here is that in factor, each different value represents what is called a level. In our case, the factor “continent” has 5 levels: “Africa”, “Americas”, “Asia”, “Europe”, and “Oceania.” R will only accept values that match one of the levels. If you add a new row that has a different value for continent (such as Nordic in our case), it will become NA. More specifically, the warning was telling us that we unsuccessfully added “Nordic” to our continent factor, but 2016 (a numeric), 5000000 (a numeric), 80.3 (a numeric), 49400.0 (a numeric) and FALSE (a logical) were successfully added to country, year, pop, lifeExp, gdpPercap and below_average respectively, since those variables are not factors. ‘Norway’ was also successfully added since it corresponds to an existing level. To successfully add a gapminder row with a “Nordic” continent, we can add “Nordic” as a level of the factor. # Add Nordic as a level of the factor levels(gapminder$continent)&lt;-c(levels(gapminder$continent), &quot;Nordic&quot;) # Confirm it&#39;s been added levels(gapminder$continent) ## [1] &quot;Africa&quot; &quot;Americas&quot; &quot;Asia&quot; &quot;Europe&quot; &quot;Oceania&quot; &quot;Nordic&quot; # Add the row to gapminder gapminder_norway&lt;-rbind(gapminder, list(&#39;Norway&#39;, 2016, 5000000, &#39;Nordic&#39;, 80.3,49400.0, FALSE)) Now, let’s confirm that the row has been added and that the factor column doesn’t cause problems: tail(gapminder_norway) ## country year pop continent lifeExp gdpPercap below_average ## 1700 Zimbabwe 1987 9216418 Africa 62.351 706.1573 TRUE ## 1701 Zimbabwe 1992 10704340 Africa 60.377 693.4208 TRUE ## 1702 Zimbabwe 1997 11404948 Africa 46.809 792.4500 TRUE ## 1703 Zimbabwe 2002 11926563 Africa 39.989 672.0386 TRUE ## 1704 Zimbabwe 2007 12311143 Africa 43.487 469.7093 TRUE ## 1705 Norway 2016 5000000 Nordic 80.300 49400.0000 FALSE To successfully add the row, our options were to either work with the character vector, which makes adding rows less cumbersome, but doesn’t include the useful categories of the factor; alternatively, we could use a factor variable, in which case adding a new row will take a bit more effort to babysit the factor levels. The option you choose will likely depend on the context of the task at hand. 5.4 Appending to a data frame The key to remember when adding data to a data frame is that columns are vectors and rows are lists. We can also glue two data frames together with rbind: gapminder&lt;-rbind(gapminder, gapminder) # Having stacked two gapminder datasets on top of each other, # we&#39;d now expect twice the number of rows as in the original dataset nrow(gapminder) ## [1] 3408 Let’s take a look at the dataset: tail(gapminder, n=3) ## country year pop continent lifeExp gdpPercap below_average ## 3406 Zimbabwe 1997 11404948 Africa 46.809 792.4500 TRUE ## 3407 Zimbabwe 2002 11926563 Africa 39.989 672.0386 TRUE ## 3408 Zimbabwe 2007 12311143 Africa 43.487 469.7093 TRUE If the row names are unnecessarily complicated and you want to remove them and have R rename them sequentially, you can use the following: rownames(gapminder)&lt;-NULL head(gapminder) ## country year pop continent lifeExp gdpPercap below_average ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 TRUE ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 TRUE ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 TRUE ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 TRUE ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 TRUE ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 TRUE "],["subsetting-data.html", "6 Subsetting Data 6.1 Accessing elements using their indices 6.2 Skipping and removing elements 6.3 Subsetting by name 6.4 Subsetting through other logical operations 6.5 Data frames", " 6 Subsetting Data R has many powerful subset operators. Mastering them will allow you to easily perform complex operations on any kind of dataset. There are six different ways we can subset any kind of object, and three different subsetting operators for the different data structures. Let’s start with the workhorse of R: a simple numeric vector. # We&#39;ll define a new vector x x&lt;-c(5.4, 6.2, 7.1, 4.8, 7.5) names(x)&lt;-c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;) And then, let’s print out the vector: x ## a b c d e ## 5.4 6.2 7.1 4.8 7.5 Now that we’ve created a dummy vector to play with, let’s explore how we can access their contents. 6.1 Accessing elements using their indices To extract elements of a vector, we can use the index number associated with that element. For example, if we wanted to extract the first element of vector x, we can use the following notation: x[1] ## a ## 5.4 Let’s say we want to extract the fourth element: x[4] ## d ## 4.8 The square brackets operator is actually a function. For vectors and matrices, it means “get me the nth element.” We can ask for multiple elements at once. For example, let’s say we want the first and third elements: x[c(1,3)] ## a c ## 5.4 7.1 We can also extract slices of the vector using this notation. Let’s say we want to extract elements 1 to 4: x[1:4] ## a b c d ## 5.4 6.2 7.1 4.8 Just to clarify the notation above, the : operator creates a sequence of numbers from the left elements to the right. So, for example: 1:4 ## [1] 1 2 3 4 And that’s equivalent to the following: c(1,2,3,4) ## [1] 1 2 3 4 We can also ask for the same element multiple times: x[c(1,1,3)] ## a a c ## 5.4 5.4 7.1 If we ask for an index that’s beyond the length of the vector, R will return a missing value: x[6] ## &lt;NA&gt; ## NA This output is a vector of length one containing an NA, whose name is also NA. If we ask for the 0th element, we get an empty vector: x[0] ## named numeric(0) You’ve probably already picked up on this, but in R indexing begins with one. This is probably fairly intuitive especially if you’re new to programming, but if you’re coming to R from another programming language like C or Python where indexing begins with zero, this can take a bit of getting used to. 6.2 Skipping and removing elements If we use a negative number as the index of a vector, R will return every element except for the one specified. So, for example, if we use an index number of negative 2, R will omit element B from the output. x[-2] ## a c d e ## 5.4 7.1 4.8 7.5 It’s also possible to skip multiple elements. For example, let’s say we want to omit the first and fifth elements: x[c(-1,-5)] ## b c d ## 6.2 7.1 4.8 One thing that can sometimes trip people up when trying to skip slices of a vector is the order of operations. For example, if we want to omit elements one through three in x, it might make sense to write the following: x[-1:3] This gives a somewhat cryptic error. What’s happening is that R is reading the -1:3 as a vector with integers ranging from -1 to 3. If we want to omit elements 1 through 3 in x, we have to wrap the 1:3 in brackets, so that the minus operator applies to the result: x[-(1:3)] ## d e ## 4.8 7.5 To remove elements from a vector, we need to assign the result back into the variable. So, let’s say we want to omit element D, and make this deletion permanent in x: x&lt;-x[-4] x ## a b c e ## 5.4 6.2 7.1 7.5 6.3 Subsetting by name We can extract elements by using their names, instead of extracting by index. # Let&#39;s name a vector on the fly x&lt;-c(a=5.4, b=6.2, c=7.1, d=4.8, e=7.5) # extract a and c by name x[c(&quot;a&quot;, &quot;c&quot;)] ## a c ## 5.4 7.1 This is usually a much more reliable way to subset objects: the position of various elements can often change when chaining together subsetting operations, but the names will always remain the same! 6.4 Subsetting through other logical operations We can also use any logical vector to subset. Let’s say we want to extract the third and fifth elements of x. We can extract these elements by passing a vector in which the third and fifth elements are set to “TRUE” and everything else is set to “FALSE”: x[c(FALSE, FALSE, TRUE, FALSE, TRUE)] ## c e ## 7.1 7.5 Because comparison vectors (i.e. greater than, less than, equal to) evaluate to logical vectors, we can also use them to concisely subset vectors. For example, subsetting with “x greater than 7” gives us the same output as before: x[x&gt;7] ## c e ## 7.1 7.5 Breaking this down a bit, what’s happening is that the statement first evaluates x&gt;7, which generates a corresponding logical vector c(FALSE, FALSE, TRUE, FALSE, TRUE), and then selects the elements of x corresponding to the TRUE values. We can use a comparison vector to mimic the previous method of indexing by name # remember you have to use == rather than = for comparisons x[names(x)==&quot;a&quot;] ## a ## 5.4 6.5 Data frames When extracting sections of data frames, recall that data frames are lists under the hood, so similar rules to the ones we’ve already discussed apply. But the big difference is that data frames are two dimensional objects, so some additional considerations apply. Using brackets with one argument to index will act the same way as for lists, where each list element corresponds to a column. The resulting object will be a data frame. For example, let’s pull out the third column in gapminder as its own data frame: head(gapminder[3]) ## pop ## 1 8425333 ## 2 9240934 ## 3 10267083 ## 4 11537966 ## 5 13079460 ## 6 14880372 Similarly, double brackets will extract a single column as a vector: head(gapminder[[&quot;lifeExp&quot;]]) ## [1] 28.801 30.332 31.997 34.020 36.088 38.438 The dollar-sign operator also provides a convenient way to extract columns by name: # extracts year column head(gapminder$year) ## [1] 1952 1957 1962 1967 1972 1977 To select specific data frame rows and or columns, you can enclose two arguments in brackets. For example, if we want to extract the first three rows of gapminder, we supply 1:3 as the first argument, and leave the second argument blank (which indicates we want all the columns): gapminder[1:3, ] ## country year pop continent lifeExp gdpPercap below_average ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 TRUE ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 TRUE ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 TRUE If we subset a single row, the result will be a data frame (since the elements are mixed types) # Extracts third row of gapminder gapminder[3, ] ## country year pop continent lifeExp gdpPercap below_average ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 TRUE But it’s important to emphase that while a single row will be a data frame, a single column will be extracted as a vector (but you can change that if you’d like by setting drop=FALSE) "],["dataframe-manipulation-with-dplyr.html", "7 Dataframe Manipulation with dplyr 7.1 The dplyr package 7.2 Using select() 7.3 Using filter 7.4 Using group_by() and summarize() 7.5 Using summarize 7.6 count() and n() 7.7 Using mutate()", " 7 Dataframe Manipulation with dplyr Now, we’re going to talk about some techniques for manipulating data frames. The manipulation of dataframes means many things to many researchers. For example, we might want to select certain observations(or rows), or select certain variables(or columns), group data by certain variables, or calculate summary statistics for subgroups. We can perform these sorts of operations using the normal base R operations. For example, let’s say we want to calculate the mean of gdpPercap for the African countries in gapminder: mean(gapminder[gapminder$continent==&quot;Africa&quot;, &quot;gdpPercap&quot;]) ## [1] 2193.755 Or, say we want to calculate the mean of gdpPercap for the Americas mean(gapminder[gapminder$continent==&quot;Americas&quot;, &quot;gdpPercap&quot;]) ## [1] 7136.11 Or, alternatively, let’s see the mean of gdpPercap for countries in Asia: mean(gapminder[gapminder$continent==&quot;Asia&quot;, &quot;gdpPercap&quot;]) ## [1] 7902.15 This syntax works, but it isn’t very efficient and can quickly become tedious because of how much repetition it involves. Repeating yourself will cost you time, both now and later. It could also potentially lead to some nasty bugs, so we want to cut down on repetition as much as possible. 7.1 The dplyr package This is where dplyr comes in. The dplyr package provides a number of very useful functions for manipulating data frames in a way that can reduce the repetition we noted above, as well as reduce the probability of making errors. It’s syntax is very efficient, so it can also probably save you some typing and make your code more readable (to yourself and others), We’ll cover 6 of the most common dplyr functions: They are select, filter, group_by, summarize, count and n, and mutate. We’ll also discuss the pipe (%&gt;%) which can be used to combine different dplyr functions and chain together your code in an efficient way. Please go ahead and install dplyr if you haven’t already using the following: install.packages(&quot;dplyr&quot;) And, don’t forget to load the library as well: library(&quot;dplyr&quot;) 7.2 Using select() Let’s start with the select function, which allows us to pluck out the columns we need and set aside the columns that we don’t. This can be useful when you’re dealing with a large dataset with a bunch of superfluous variables, and you want to create a more tractable dataset. Let’s see how this works by selecting the year, country, and gdpPercap variables from the gapminder dataset. We’ll assign this selection to a new object called year_country_gdp year_country_gdp&lt;-select(gapminder, year, country, gdpPercap) If you open up year_country_gdp, you’dd see that it only contains the year, country, and gdpPercap variables. In the example above, we used ‘normal’ grammar, but the strengths of dplyr are best showcased by combining several functions using pipes. Since the pipes grammar is unlike anything we’ve encountered in R so far, let’s get a sense of how pipes work by repeating what we did above using pipes: year_country_gdp&lt;gapminder %&gt;% select(year, country, gdpPercap) ## year country gdpPercap ## [1,] FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE ## [4,] FALSE FALSE FALSE ## [5,] FALSE FALSE FALSE ## [6,] FALSE FALSE FALSE ## [7,] FALSE FALSE FALSE ## [8,] FALSE FALSE FALSE ## [9,] FALSE FALSE FALSE ## [10,] FALSE FALSE FALSE ## [11,] FALSE FALSE FALSE ## [12,] FALSE FALSE FALSE ## [13,] FALSE FALSE FALSE ## [14,] FALSE FALSE FALSE ## [15,] FALSE FALSE FALSE ## [16,] FALSE FALSE FALSE ## [17,] FALSE FALSE FALSE ## [18,] FALSE FALSE FALSE ## [19,] FALSE FALSE FALSE ## [20,] FALSE FALSE FALSE ## [21,] FALSE FALSE FALSE ## [22,] FALSE FALSE FALSE ## [23,] FALSE FALSE FALSE ## [24,] FALSE FALSE FALSE ## [25,] FALSE FALSE FALSE ## [26,] FALSE FALSE FALSE ## [27,] FALSE FALSE FALSE ## [28,] FALSE FALSE FALSE ## [29,] FALSE FALSE FALSE ## [30,] FALSE FALSE FALSE ## [31,] FALSE FALSE FALSE ## [32,] FALSE FALSE FALSE ## [33,] FALSE FALSE FALSE ## [34,] FALSE FALSE FALSE ## [35,] FALSE FALSE FALSE ## [36,] FALSE FALSE FALSE ## [37,] FALSE FALSE FALSE ## [38,] FALSE FALSE FALSE ## [39,] FALSE FALSE FALSE ## [40,] FALSE FALSE FALSE ## [41,] FALSE FALSE FALSE ## [42,] FALSE FALSE FALSE ## [43,] FALSE FALSE FALSE ## [44,] FALSE FALSE FALSE ## [45,] FALSE FALSE FALSE ## [46,] FALSE FALSE FALSE ## [47,] FALSE FALSE FALSE ## [48,] FALSE FALSE FALSE ## [49,] FALSE FALSE FALSE ## [50,] FALSE FALSE FALSE ## [51,] FALSE FALSE FALSE ## [52,] FALSE FALSE FALSE ## [53,] FALSE FALSE FALSE ## [54,] FALSE FALSE FALSE ## [55,] FALSE FALSE FALSE ## [56,] FALSE FALSE FALSE ## [57,] FALSE FALSE FALSE ## [58,] FALSE FALSE FALSE ## [59,] FALSE FALSE FALSE ## [60,] FALSE FALSE FALSE ## [61,] FALSE FALSE FALSE ## [62,] FALSE FALSE FALSE ## [63,] FALSE FALSE FALSE ## [64,] FALSE FALSE FALSE ## [65,] FALSE FALSE FALSE ## [66,] FALSE FALSE FALSE ## [67,] FALSE FALSE FALSE ## [68,] FALSE FALSE FALSE ## [69,] FALSE FALSE FALSE ## [70,] FALSE FALSE FALSE ## [71,] FALSE FALSE FALSE ## [72,] FALSE FALSE FALSE ## [73,] FALSE FALSE FALSE ## [74,] FALSE FALSE FALSE ## [75,] FALSE FALSE FALSE ## [76,] FALSE FALSE FALSE ## [77,] FALSE FALSE FALSE ## [78,] FALSE FALSE FALSE ## [79,] FALSE FALSE FALSE ## [80,] FALSE FALSE FALSE ## [81,] FALSE FALSE FALSE ## [82,] FALSE FALSE FALSE ## [83,] FALSE FALSE FALSE ## [84,] FALSE FALSE FALSE ## [85,] FALSE FALSE FALSE ## [86,] FALSE FALSE FALSE ## [87,] FALSE FALSE FALSE ## [88,] FALSE FALSE FALSE ## [89,] FALSE FALSE FALSE ## [90,] FALSE FALSE FALSE ## [91,] FALSE FALSE FALSE ## [92,] FALSE FALSE FALSE ## [93,] FALSE FALSE FALSE ## [94,] FALSE FALSE FALSE ## [95,] FALSE FALSE FALSE ## [96,] FALSE FALSE FALSE ## [97,] FALSE FALSE FALSE ## [98,] FALSE FALSE FALSE ## [99,] FALSE FALSE FALSE ## [100,] FALSE FALSE FALSE ## [101,] FALSE FALSE FALSE ## [102,] FALSE FALSE FALSE ## [103,] FALSE FALSE FALSE ## [104,] FALSE FALSE FALSE ## [105,] FALSE FALSE FALSE ## [106,] FALSE FALSE FALSE ## [107,] FALSE FALSE FALSE ## [108,] FALSE FALSE FALSE ## [109,] FALSE FALSE FALSE ## [110,] FALSE FALSE FALSE ## [111,] FALSE FALSE FALSE ## [112,] FALSE FALSE FALSE ## [113,] FALSE FALSE FALSE ## [114,] FALSE FALSE FALSE ## [115,] FALSE FALSE FALSE ## [116,] FALSE FALSE FALSE ## [117,] FALSE FALSE FALSE ## [118,] FALSE FALSE FALSE ## [119,] FALSE FALSE FALSE ## [120,] FALSE FALSE FALSE ## [121,] FALSE FALSE FALSE ## [122,] FALSE FALSE FALSE ## [123,] FALSE FALSE FALSE ## [124,] FALSE FALSE FALSE ## [125,] FALSE FALSE FALSE ## [126,] FALSE FALSE FALSE ## [127,] FALSE FALSE FALSE ## [128,] FALSE FALSE FALSE ## [129,] FALSE FALSE FALSE ## [130,] FALSE FALSE FALSE ## [131,] FALSE FALSE FALSE ## [132,] FALSE FALSE FALSE ## [133,] FALSE FALSE FALSE ## [134,] FALSE FALSE FALSE ## [135,] FALSE FALSE FALSE ## [136,] FALSE FALSE FALSE ## [137,] FALSE FALSE FALSE ## [138,] FALSE FALSE FALSE ## [139,] FALSE FALSE FALSE ## [140,] FALSE FALSE FALSE ## [141,] FALSE FALSE FALSE ## [142,] FALSE FALSE FALSE ## [143,] FALSE FALSE FALSE ## [144,] FALSE FALSE FALSE ## [145,] FALSE FALSE FALSE ## [146,] FALSE FALSE FALSE ## [147,] FALSE FALSE FALSE ## [148,] FALSE FALSE FALSE ## [149,] FALSE FALSE FALSE ## [150,] FALSE FALSE FALSE ## [151,] FALSE FALSE FALSE ## [152,] FALSE FALSE FALSE ## [153,] FALSE FALSE FALSE ## [154,] FALSE FALSE FALSE ## [155,] FALSE FALSE FALSE ## [156,] FALSE FALSE FALSE ## [157,] FALSE FALSE FALSE ## [158,] FALSE FALSE FALSE ## [159,] FALSE FALSE FALSE ## [160,] FALSE FALSE FALSE ## [161,] FALSE FALSE FALSE ## [162,] FALSE FALSE FALSE ## [163,] FALSE FALSE FALSE ## [164,] FALSE FALSE FALSE ## [165,] FALSE FALSE FALSE ## [166,] FALSE FALSE FALSE ## [167,] FALSE FALSE FALSE ## [168,] FALSE FALSE FALSE ## [169,] FALSE FALSE FALSE ## [170,] FALSE FALSE FALSE ## [171,] FALSE FALSE FALSE ## [172,] FALSE FALSE FALSE ## [173,] FALSE FALSE FALSE ## [174,] FALSE FALSE FALSE ## [175,] FALSE FALSE FALSE ## [176,] FALSE FALSE FALSE ## [177,] FALSE FALSE FALSE ## [178,] FALSE FALSE FALSE ## [179,] FALSE FALSE FALSE ## [180,] FALSE FALSE FALSE ## [181,] FALSE FALSE FALSE ## [182,] FALSE FALSE FALSE ## [183,] FALSE FALSE FALSE ## [184,] FALSE FALSE FALSE ## [185,] FALSE FALSE FALSE ## [186,] FALSE FALSE FALSE ## [187,] FALSE FALSE FALSE ## [188,] FALSE FALSE FALSE ## [189,] FALSE FALSE FALSE ## [190,] FALSE FALSE FALSE ## [191,] FALSE FALSE FALSE ## [192,] FALSE FALSE FALSE ## [193,] FALSE FALSE FALSE ## [194,] FALSE FALSE FALSE ## [195,] FALSE FALSE FALSE ## [196,] FALSE FALSE FALSE ## [197,] FALSE FALSE FALSE ## [198,] FALSE FALSE FALSE ## [199,] FALSE FALSE FALSE ## [200,] FALSE FALSE FALSE ## [201,] FALSE FALSE FALSE ## [202,] FALSE FALSE FALSE ## [203,] FALSE FALSE FALSE ## [204,] FALSE FALSE FALSE ## [205,] FALSE FALSE FALSE ## [206,] FALSE FALSE FALSE ## [207,] FALSE FALSE FALSE ## [208,] FALSE FALSE FALSE ## [209,] FALSE FALSE FALSE ## [210,] FALSE FALSE FALSE ## [211,] FALSE FALSE FALSE ## [212,] FALSE FALSE FALSE ## [213,] FALSE FALSE FALSE ## [214,] FALSE FALSE FALSE ## [215,] FALSE FALSE FALSE ## [216,] FALSE FALSE FALSE ## [217,] FALSE FALSE FALSE ## [218,] FALSE FALSE FALSE ## [219,] FALSE FALSE FALSE ## [220,] FALSE FALSE FALSE ## [221,] FALSE FALSE FALSE ## [222,] FALSE FALSE FALSE ## [223,] FALSE FALSE FALSE ## [224,] FALSE FALSE FALSE ## [225,] FALSE FALSE FALSE ## [226,] FALSE FALSE FALSE ## [227,] FALSE FALSE FALSE ## [228,] FALSE FALSE FALSE ## [229,] FALSE FALSE FALSE ## [230,] FALSE FALSE FALSE ## [231,] FALSE FALSE FALSE ## [232,] FALSE FALSE FALSE ## [233,] FALSE FALSE FALSE ## [234,] FALSE FALSE FALSE ## [235,] FALSE FALSE FALSE ## [236,] FALSE FALSE FALSE ## [237,] FALSE FALSE FALSE ## [238,] FALSE FALSE FALSE ## [239,] FALSE FALSE FALSE ## [240,] FALSE FALSE FALSE ## [241,] FALSE FALSE FALSE ## [242,] FALSE FALSE FALSE ## [243,] FALSE FALSE FALSE ## [244,] FALSE FALSE FALSE ## [245,] FALSE FALSE FALSE ## [246,] FALSE FALSE FALSE ## [247,] FALSE FALSE FALSE ## [248,] FALSE FALSE FALSE ## [249,] FALSE FALSE FALSE ## [250,] FALSE FALSE FALSE ## [251,] FALSE FALSE FALSE ## [252,] FALSE FALSE FALSE ## [253,] FALSE FALSE FALSE ## [254,] FALSE FALSE FALSE ## [255,] FALSE FALSE FALSE ## [256,] FALSE FALSE FALSE ## [257,] FALSE FALSE FALSE ## [258,] FALSE FALSE FALSE ## [259,] FALSE FALSE FALSE ## [260,] FALSE FALSE FALSE ## [261,] FALSE FALSE FALSE ## [262,] FALSE FALSE FALSE ## [263,] FALSE FALSE FALSE ## [264,] FALSE FALSE FALSE ## [265,] FALSE FALSE FALSE ## [266,] FALSE FALSE FALSE ## [267,] FALSE FALSE FALSE ## [268,] FALSE FALSE FALSE ## [269,] FALSE FALSE FALSE ## [270,] FALSE FALSE FALSE ## [271,] FALSE FALSE FALSE ## [272,] FALSE FALSE FALSE ## [273,] FALSE FALSE FALSE ## [274,] FALSE FALSE FALSE ## [275,] FALSE FALSE FALSE ## [276,] FALSE FALSE FALSE ## [277,] FALSE FALSE FALSE ## [278,] FALSE FALSE FALSE ## [279,] FALSE FALSE FALSE ## [280,] FALSE FALSE FALSE ## [281,] FALSE FALSE FALSE ## [282,] FALSE FALSE FALSE ## [283,] FALSE FALSE FALSE ## [284,] FALSE FALSE FALSE ## [285,] FALSE FALSE FALSE ## [286,] FALSE FALSE FALSE ## [287,] FALSE FALSE FALSE ## [288,] FALSE FALSE FALSE ## [289,] FALSE FALSE FALSE ## [290,] FALSE FALSE FALSE ## [291,] FALSE FALSE FALSE ## [292,] FALSE FALSE FALSE ## [293,] FALSE FALSE FALSE ## [294,] FALSE FALSE FALSE ## [295,] FALSE FALSE FALSE ## [296,] FALSE FALSE FALSE ## [297,] FALSE FALSE FALSE ## [298,] FALSE FALSE FALSE ## [299,] FALSE FALSE FALSE ## [300,] FALSE FALSE FALSE ## [301,] FALSE FALSE FALSE ## [302,] FALSE FALSE FALSE ## [303,] FALSE FALSE FALSE ## [304,] FALSE FALSE FALSE ## [305,] FALSE FALSE FALSE ## [306,] FALSE FALSE FALSE ## [307,] FALSE FALSE FALSE ## [308,] FALSE FALSE FALSE ## [309,] FALSE FALSE FALSE ## [310,] FALSE FALSE FALSE ## [311,] FALSE FALSE FALSE ## [312,] FALSE FALSE FALSE ## [313,] FALSE FALSE FALSE ## [314,] FALSE FALSE FALSE ## [315,] FALSE FALSE FALSE ## [316,] FALSE FALSE FALSE ## [317,] FALSE FALSE FALSE ## [318,] FALSE FALSE FALSE ## [319,] FALSE FALSE FALSE ## [320,] FALSE FALSE FALSE ## [321,] FALSE FALSE FALSE ## [322,] FALSE FALSE FALSE ## [323,] FALSE FALSE FALSE ## [324,] FALSE FALSE FALSE ## [325,] FALSE FALSE FALSE ## [326,] FALSE FALSE FALSE ## [327,] FALSE FALSE FALSE ## [328,] FALSE FALSE FALSE ## [329,] FALSE FALSE FALSE ## [330,] FALSE FALSE FALSE ## [331,] FALSE FALSE FALSE ## [332,] FALSE FALSE FALSE ## [333,] FALSE FALSE FALSE ## [ reached getOption(&quot;max.print&quot;) -- omitted 3075 rows ] Let’s walk through that syntax step by step. First, we summon the gapminder data frame and pass it on, using the pipe symbol (%&gt;%), to the next step, which is the select() function. In this case we don’t specify which data object we use in the select function since this information has already been passed to the select function from the previous pipe. 7.3 Using filter Let’s say we want to create a dataset that only has the year, country, and gdpPercap variables, and also restricts its observations to only European countries. So, instead of just limiting the columns in the dataset, we also want to limit the rows based on a condition. We can do this by combining select and filter using pipes: year_country_gdp_euro&lt;-gapminder %&gt;% filter(continent==&quot;Europe&quot;) %&gt;% select(year, country, gdpPercap) head(year_country_gdp_euro) ## year country gdpPercap ## 1 1952 Albania 1601.056 ## 2 1957 Albania 1942.284 ## 3 1962 Albania 2312.889 ## 4 1967 Albania 2760.197 ## 5 1972 Albania 3313.422 ## 6 1977 Albania 3533.004 Note that the order of operations is important here. If we used ‘select’ first, filter would not be able to find the variable continent since we would have removed it in the previous step. 7.4 Using group_by() and summarize() We mentioned earlier that we want to reduce the error-prone repetitiveness of base R, but up to now we haven’t done that since we’d have to repeat the code above for each continent. But instead of using filter and setting continent==\"Europe\"we could use group_by(), which will essentially use every unique criteria you could have used in filter. Let’s see what the group_by() function does to the structure of a dataset. We’ll start by examining the structure of gapminder: str(gapminder) ## &#39;data.frame&#39;: 3408 obs. of 7 variables: ## $ country : chr &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... ## $ year : int 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ pop : num 8425333 9240934 10267083 11537966 13079460 ... ## $ continent : Factor w/ 6 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ lifeExp : num 28.8 30.3 32 34 36.1 ... ## $ gdpPercap : num 779 821 853 836 740 ... ## $ below_average: logi TRUE TRUE TRUE TRUE TRUE TRUE ... Now let’s see the structure of the gapminder dataset once it’s been grouped by the continent variable gapminder %&gt;% group_by(continent) %&gt;% str() ## grouped_df [3,408 × 7] (S3: grouped_df/tbl_df/tbl/data.frame) ## $ country : chr [1:3408] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... ## $ year : int [1:3408] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ pop : num [1:3408] 8425333 9240934 10267083 11537966 13079460 ... ## $ continent : Factor w/ 6 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... ## $ lifeExp : num [1:3408] 28.8 30.3 32 34 36.1 ... ## $ gdpPercap : num [1:3408] 779 821 853 836 740 ... ## $ below_average: logi [1:3408] TRUE TRUE TRUE TRUE TRUE TRUE ... ## - attr(*, &quot;groups&quot;)= tibble [5 × 2] (S3: tbl_df/tbl/data.frame) ## ..$ continent: Factor w/ 6 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 1 2 3 4 5 ## ..$ .rows : list&lt;int&gt; [1:5] ## .. ..$ : int [1:1248] 25 26 27 28 29 30 31 32 33 34 ... ## .. ..$ : int [1:600] 49 50 51 52 53 54 55 56 57 58 ... ## .. ..$ : int [1:792] 1 2 3 4 5 6 7 8 9 10 ... ## .. ..$ : int [1:720] 13 14 15 16 17 18 19 20 21 22 ... ## .. ..$ : int [1:48] 61 62 63 64 65 66 67 68 69 70 ... ## .. ..@ ptype: int(0) ## ..- attr(*, &quot;.drop&quot;)= logi TRUE You’ll notice that the structure of the dataframe where we used group_by is not the same as the structure of the original gapminder dataset. A grouped data frame can be thought of as a list where each item in the list is a data frame which contains only the rows that correspond to a given value of continent, in the context of our example. 7.5 Using summarize The example above may have seemed on the mundane side, but we can see the power of group_by when we use it in conjunction with the summarize function. This allows us to create new variables by using functions that repeat for each of the continent specific data frames. In other words, we can use the group_by function to split our original dataframe into multiple pieces, and then run functions on those groups. This will make more sense in the context of an example. Let’s say we want to generate a table that contains gapminder’s continent groups in one column, and the continent-level mean of gdp per capita in the other column. We can generate such a table with the following: gdp_by_continents&lt;-gapminder %&gt;% group_by(continent) %&gt;% summarize(mean_gdpPercap=mean(gdpPercap)) gdp_by_continents ## # A tibble: 5 x 2 ## continent mean_gdpPercap ## * &lt;fct&gt; &lt;dbl&gt; ## 1 Africa 2194. ## 2 Americas 7136. ## 3 Asia 7902. ## 4 Europe 14469. ## 5 Oceania 18622. In the code above, we took the original gapminder data, grouped it by the continent variable, calculated the continent-level mean and stored it in a new column called mean_gdpPercap, and then assigned this new dataset of continent-level mean GDP per capita to a new object called gdp_by_continents. We can also use the same group_by() function to group by multiple variables. For example, let’s group by both year and continent, and then generate a table that contains the mean of continent-level gdpPercap for every distinct year: gdp_bycontinents_byyear&lt;-gapminder %&gt;% group_by(continent, year) %&gt;% summarize(mean_gdpPercap=mean(gdpPercap)) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. Things become even more powerful when you realize that you’re not limited to definining only 1 new variable in summarize. Let’s define some additional variables to see how this works. We’ll define variables for the standard deviation of gdp per capital, as well as the mean and standard deviation of the population, in addition to the mean of gdp per capita we’ve already calculated. The code will look something like this: gdp_pop_bycontinents_byyear&lt;-gapminder %&gt;% group_by(continent, year) %&gt;% summarize(mean_gdpPercap=mean(gdpPercap), sd_gdpPercap=sd(gdpPercap), mean_pop=mean(pop), sd_pop=sd(pop)) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. This object will now contain a continent-year dataset with columns containing information on continent-level mean GDP, standard deviation of GDP, the continent-level mean of population, and the continent level standard deviation of population. 7.6 count() and n() A very common operation is to count the number of observations for each group. The dplyr package comes with two related functions that help with this. They are the count() function and the n() function. For example, let’s say we want to check the number of countries included in the dataset for the year 2002. To do that, we can use the count function. This function takes the name of one or more columns that contain the groups we’re interested in, and we can optionally sort the results in descending order by adding sort=TRUE. # Will generate a dataset that provides a count of how many observations are associated # with each continent in the year 2002 gapminder %&gt;% filter(year==2002) %&gt;% count(continent, sort=TRUE) ## continent n ## 1 Africa 104 ## 2 Asia 66 ## 3 Europe 60 ## 4 Americas 50 ## 5 Oceania 4 If we need to use the number of observations in calculations, the n() function is very useful. For example, let’s say we want to get the standard error of the life expectancy for each continent: # Code will generate a table containing information on the standard error of the life expectancy variable, for each continent gapminder %&gt;% group_by(continent) %&gt;% summarize(se_le=sd(lifeExp)/sqrt(n())) ## # A tibble: 5 x 2 ## continent se_le ## * &lt;fct&gt; &lt;dbl&gt; ## 1 Africa 0.259 ## 2 Americas 0.381 ## 3 Asia 0.421 ## 4 Europe 0.202 ## 5 Oceania 0.542 It’s also possible to chain together many different summary operations. For example, let’s say we want to calculate the minimum, maximum, mean, and standard error of each continent’s per-country life-expectancy. gapminder %&gt;% group_by(continent) %&gt;% summarize( mean_le=mean(lifeExp), min_le=min(lifeExp), max_le=max(lifeExp), se_le=sd(lifeExp)/sqrt(n())) ## # A tibble: 5 x 5 ## continent mean_le min_le max_le se_le ## * &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Africa 48.9 23.6 76.4 0.259 ## 2 Americas 64.7 37.6 80.7 0.381 ## 3 Asia 60.1 28.8 82.6 0.421 ## 4 Europe 71.9 43.6 81.8 0.202 ## 5 Oceania 74.3 69.1 81.2 0.542 7.7 Using mutate() We’ll close out this section with a discussion of the mutate() function, which allows us to define new variables based on existing ones. Mutate allows us to create new variables prior to (or even after) summarizing information in the way that we just learned. # Takes gapminder, uses mutate to generate a variable that # contains GDP in units of billions, and then groups data # by continent and year, and then creates a bunch of summary # variables some of which use the variable we defined using mutate. gdp_pop_bycontinents_byear&lt;-gapminder %&gt;% mutate(gdp_billion=gdpPercap*pop/10^9) %&gt;% group_by(continent, year) %&gt;% summarize(mean_gdpPercap=mean(gdpPercap), sd_gdpPercap=sd(gdpPercap), mean_pop=mean(pop), sd_pop=sd(pop), mean_gdp_billion=mean(gdp_billion), sd_gdp_billion=sd(gdp_billion)) ## `summarise()` has grouped output by &#39;continent&#39;. You can override using the `.groups` argument. Summary Use the dplyr package to manipulate dataframes. Use select() to choose variables from a dataframe. Use filter() to choose data based on values. Use group_by() and summarize() to work with subsets of data. Use mutate() to create new variables. "],["introduction-to-visualization.html", "8 Introduction to Visualization", " 8 Introduction to Visualization Let’s start off with an example plotting the distribution of life expectancy in the gapminder dataset. The first thing we do is call the ``ggplotfunction. This function lets R know that we're creating a new plot, and any of the arguments we give theggplot() function are the global options for the plot, which means that they apply to all layers on the plot. We’ll pass in two arguments to ggplot. First, we tell ggplot what data we want to show on our graph. In this case, the dataset we want to use as the basis for our figure is the familiar gapminder dataset. For the second argument, we pass in the aes() function, which tells ggplot how variables in the data map on to aesthetic properties of the figure. In other words, we use aes() to specify what variables we want to represent on our visualization, and where to represent them with respect to the visualizations’ axes. In this case, we will tell ggplot to plot the “lifeExp” column of the gapminder data frame on the x axis. We don’t need to specify a y axis, since we’ll be drawing a histogram which will automatically show the relevant count on the y-axis. Before we start, make sure that you have the ggplot library loaded if you don’t already: library(ggplot2) Then, let’s draw our histogram with the following code: ggplot(data=gapminder, aes(x=lifeExp)) Notice that we have the beginnings of a graph, and the X axis is labeled as we specified, but we don’t have a graph yet. That’s because we need to tell ggplot how we want to visually represent the data, which we do by adding a geom layer. Since we want a histogram, we will use the geom_histogram function: ggplot(data=gapminder, aes(x=lifeExp))+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. While the histogram is a useful tool for visualizing the distribution of a single categorical variable, what if we want to compare the gdp per capita of the countries in the dataset? For that, we could use a bar (or column) plot. To simplify things, let’s look at data only from the most recent year and only from countries in the Americas. We’ll create a new object that meets those criteria with the following: gapminder_small&lt;-filter(gapminder, year==2007, continent==&quot;Americas&quot;) Now, we can use the gapminder_small object in our call to ggplot. Since we want to produce a bar graph rather than histogram, we’ll use the geom_col function. We’ll plot countries on the x axis (which are listed in alphabetic order by default) and gdp per capita on the y-axis: ggplot(data=gapminder_small, aes(x=country, y=gdpPercap))+ geom_col() This is somewhat useful, but with so many bars plotted, it’s impossible to read all the x-axis labels. A quick fix in situations like this is to add the coord_flip() function to the end of the plot code: ggplot(data=gapminder_small, aes(x=country, y=gdpPercap))+ geom_col()+ coord_flip() The examples here are to just get you started with ggplot, and the process of making graphics in R. Later in the workshop, we’ll go into a lot more depth on a variety of more advanced visualization topics, especially those relevant to work with geospatial data. For now, the main takeaway points are that we can use ggplot2 to make plots, and that we should think about graphics in layers. Thinking in these terms makes the process of visualizing data in ggplot relatively intuitive. "],["writing-data.html", "9 Writing Data 9.1 Saving plots 9.2 Writing data", " 9 Writing Data 9.1 Saving plots You can save a plot from R Studio using the Export button in the Plot window. This will give you the option of saving the plot as a pdf, png, or jpg file or another image format of your choosing. Sometimes, you may want to save plots without creating them in the ‘Plot’ window first/ Maybe you want to make a PDF document with multiple pages, each one with a different plot. Or, maybe you’re looping through multiple subsets of a file, plotting data from each subset, and you want to save each plot. In cases like these, where you want to save plots programmatically, and need a more flexible approach, you can use something called a pdf device. The pdf() function creates a new pdf device, which allows you to control the size and resolution through arguments that are passed to it. Let’s see how this works: # We&#39;ll start by setting up the pdf device pdf(&quot;Distribution-of-gdpPercap.pdf&quot;, width=12, height=4) # Then, write the code to generate the plot ggplot(data=gapminder, aes(x=gdpPercap))+ geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. # Then, remember to turn off the pdf device dev.off() ## quartz_off_screen ## 2 You can follow a similar process for different file formats like jpeg, png and so on. Just make sure to change the file extension in your code. 9.2 Writing data At some point, you’ll also want to write out data from R. We can use the write.csv function to write out csv files to disk. The write.csv function is very similar to read.csv from before. Let’s create a subset of the gapminder data for Australia, and then write this data out to disk. By default, the file will write to your working directory. # create subset and assign to &quot;aust_subset&quot; object aust_subset&lt;-filter(gapminder, country==&quot;Australia&quot;) write.csv(aust_subset, file=&quot;cleaned-data/gapminder-aus.csv&quot;) Let’s open up the file we just created in our cleaned-data directory. When we open it up we can see that we have the correctly formatted data from the Australia observations. But note that there are row numbers associated with the data that aren’t useful to us at this point. To get information on how you can change this behavior, you can consult the function’s documentation: ?write.csv The documentation will tell you that if you want to get rid of the row names, you can set the row.names argument in write.csv equal to false: write.csv( aust_subset, file=&quot;cleaned-data/gapminder-aus.csv&quot;, row.names=FALSE) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
